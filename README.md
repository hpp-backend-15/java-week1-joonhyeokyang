# java-week1-joonhyeokyang

# 동시성 관리

## 1. 동시성(Concurrent)이란?

- 컴퓨터의 CPU는 한 번에 한 개의 작업(프로세스/프로그램)만을 처리할 수 있다.
- 또한, 한 개의 프로세스에는 여러 \*쓰레드가 있을 수 있다. (*작업 단위)
- 긴 시간이 필요한 작업이 있어서 그 뒤의 작업이 다 멈춰지면 두 가지 문제가 있다.

### 1. 컴퓨팅 리소스의 비효율
  - 사실 긴 시간의 작업은 두가지로 이루어진다. IO(Network, Device)와 컴퓨팅 작업이다.
  - IO 작업시에는, 컴퓨팅 리소스를 사용하지 않는다. 즉, 귀중한 컴퓨팅 자원이 낭비된다.
  - 대부분의 현대 CPU는 이때 동안 다른 작업을 하도록 설계되어 있다. 이를 `컨텍스트 스위칭`이라 한다.
  - `컨텍스트 스위칭`을 통하여, IO 작업시 다른 작업을 하여 효율적으로 CPU를 사용한다.

### 2. 낮은 반응성(reactiveness)
  - 엄청나게 오래 걸리는 작업이 있어서, 다른 작업들이 모두 기다린다고 해보자.
  - 키보드, 마우스를 눌러도 아무런 반응이 없다면 이용자는 실망한다.

- 위와 같은 이유로, CPU는 큰 작업을 쪼개어 나누어 번갈아가면서 한다.
- 프로세스를 작게 나누어 실행하기도 하지만, **쓰레드**를 여러개로 나누어 실행하기도 한다.
- 여기서 쓰레드는 한 프로세스의 공유 자원을 모두 동시에 접근 가능하기에, `동시성` 이슈가 생긴다.

## 2. 동시성 관리
- 동시성을 관리하는 가장 간단한 방법은 "격리"하는 것이다.
- 현재 포인트를 충전하는 작업은 사실 두가지다. `충전할 포인트 조회`와 `충전 내역 저장, 실제 충전`이다.
- 결국 아래와 같이 `두 작업을 하나로 묶어서 실행`해버리면 된다. 다만 성능 저하가 예상된다.
<img width="635" alt="image" src="https://github.com/user-attachments/assets/bb24f1fa-061f-4786-8e59-20e831efd344">

- `두 작업을 하나로 묶어서 실행`하는 방법으로는 `synchronized`, `lock` 등이 있다.
  - 원리는 간단하다. 임계 구역을 정해놓고, 한 쓰레드가 실행될 때, 다른 모든 쓰레드는 임계 구역에 쓰레드가 없을 때 까지 대기(`block`)한다.
  - 한 쓰레드의 실행이 끝나면 `lock`을 반환하며, 다음 쓰레드가 실행 되도록한다.
- 다른 방법으론 `CAS` 알고리즘을 지원하는 `Concurrent*` 자료구조를 사용하면 된다.
  - CAS(Compare And Swap) 알고리즘은 `synchronized` 방식과 다르게, `non-blocking`하게 공유 자원에 접근한다.
  - `기존 값`, `변경 값`을 받고, `메모리 현재 값(Destination)` 을 갖고 있다가, 변경 시 `메모리 현재 값`이 같다면, 적용하고 다르다면 적용하지 않는다.
  - 즉, `메모리 현재 값`이 같다면, 다른 누군가가 `메모리 현재 값`을 변경했기에, 값 변경을 하지 않는 것이다.

- 다 적고나니, DB에서 사용하는 `비관락(선점락)`과 `낙관락(비선점락)`이랑 원리가 똑같다. (~~어?~~)

## 3. 더 나아가서  
허재 코치님은 `비동기`와 `큐`를 이용하여 더 개선된 성능으로 동시성을 관리할 수 있다 했다.  
그럼 뭔가 레디스 분산락을 Java로 구현하는건가 싶다. 끗  
